/*
演算子は演算する対象を持ち、
この演算子の対象のことを被演算子（オペランド）と呼ぶ。
*/

/*
以下は+演算子の対象となっている1と2という2つの値がオペランド。
2つのオペランドを取る演算子を二項演算子と呼ぶ。
*/

1 + 2;

/*
1つの演算子に対して1つのオペランドだけを取るものもある。
1つのオペランドを取る演算子を単項演算子と呼ぶ。
*/

let num = 1;
num++;

// -------------------------------------------------

// 二項演算値

// プラス演算子（+）
console.log(1 + 1); // => 2
// 文字列結合演算子（+）
const value = "文字列" + "結合";
console.log(value); // => "文字列結合"
// マイナス演算子（-）
console.log(10 - 0.5); // => 9.5
// 乗算演算子（*）
console.log(10 * 0.5); // => 5
// 除算演算子（/）
console.log(10 / 0.5); // => 20
// 剰余演算子（%）
console.log(8 % 2); // => 0
// [ES2016] べき乗演算子（**）
console.log(2 ** 4); // => 16

// -------------------------------------------------

// 単項演算値

// 単項プラス演算子（+）
console.log(+"1"); // => 1（数値）
console.log(+"文字列"); // => NaN
/*
    Numberコンストラクタ関数やparseInt関数などの明示的な変換方法が存在するため,
    単項プラス演算子は文字列から数値への変換に使うべきではない。
*/
// 単項マイナス演算子（-）
console.log(-(-1)); // => 1
console.log(-"1"); // => -1
// インクリメント演算子（++）・デクリメント演算子（--）
let x = 1;
console.log(x++); // => 1
console.log(x);   // => 2
let y = 1;
console.log(++y); // => 2
console.log(y);   // => 2

// -------------------------------------------------

/*
    NaNは"Not-a-Number"の略称で、
    数値ではないがNumber型の値を表現している。
    NaNはどの値とも（NaN自身に対しても）一致しない特性があり、
    Number.isNaN静的メソッドを使うことでNaNの判定を行える。
*/

// 自分自身とも一致しない
console.log(NaN === NaN); // => false
// Number型である
console.log(typeof NaN); // => "number"
// Number.isNaNでNaNかどうかを判定
console.log(Number.isNaN(NaN)); // => true

// -------------------------------------------------

// 比較演算値

// 厳密等価演算子（===）
console.log(1 === 1); // => true
console.log(1 === "1"); // => false
const objA = {};
const objB = {};
console.log(objA === objB); // => false
console.log(objA === objA); // => true

// 等価演算子（==）
console.log(1 == "1"); // => true
console.log(1 == "01"); // => true
console.log(0 == false); // => true
console.log(0 == null); // => false
console.log(null == undefined); // => true
/*
    意図しない挙動となることがあるため、暗黙的な型変換が行われる
    等価演算子（==）を使うべきではない。
    代わりに、厳密等価演算子（===）を使い、
    異なる型を比較したい場合は明示的に型を合わせるべき。
*/
// 等価演算子（==）を使う例外的なケース
const value0 = undefined; /* または null */
// === では2つの値と比較しないといけない
if (value0 === null || value === undefined) {
    console.log("valueがnullまたはundefinedである場合の処理");
}
// == では null と比較するだけでよい
if (value0 == null) {
    console.log("valueがnullまたはundefinedである場合の処理");
}

// 大なり演算子/より大きい（>）
console.log(42 > 21); // => true
console.log(42 > 42); // => false

// -------------------------------------------------

// ビット演算子

// ビット論理積（&）
console.log(15     & 9);      // => 9
// 同じ位の各ビット同士をAND演算する（上位の`0`は省略）
// 1111
// 1001
// ----
// 1001
console.log(0b1111 & 0b1001); // => 0b1001

// ビット論理和（|）
console.log(15     | 9);      // => 15
// 同じ位の各ビット同士をOR演算する（上位の`0`は省略）
// 1111
// 1001
// ----
// 1111
console.log(0b1111 | 0b1001); // => 0b1111

// ビット排他的論理和（^）
console.log(15     ^ 9);      // => 6
// 同じ位の各ビット同士をXOR演算する（上位の`0`は省略）
// 1111
// 1001
// ----
// 0110
console.log(0b1111 ^ 0b1001); // => 0b0110

// ビット否定（~）
console.log(~15); // => -16
/* 
    JavaScriptでは0も、if文ではfalseとして扱われる。
    そのため、~indexOfの結果が0となるのは、
    その文字列が見つからなかった場合だけとなる。
    次のコードのように否定演算子（~）と
    indexOfメソッドを使ったイディオムが一部では使われていた。

    否定演算子（~）とindexOfメソッドを使ったイディオムは、
    includesメソッドに置き換えられる。
*/
const str = "森森木森森";
// indexOfメソッドは見つからなかった場合は -1 を返す
if (str.indexOf("木") !== -1) {
    console.log("木を見つけました");
}
// 否定演算子（`~`）で同じ動作を実装
// (~(-1)) は 0 となるため、見つからなかった場合はif文の中身は実行されない
if (~str.indexOf("木")) {
    console.log("木を見つけました");
}

// 左シフト演算子（<<）：左にあふれたビットは破棄され、0のビットを右から詰める。
console.log(     9 << 2); // => 36
console.log(0b1001 << 2); // => 0b10_0100

// 右シフト演算子（>>）：右にあふれたビットは破棄され、左端のビットのコピーを左から詰める。
console.log((-9) >> 2); // => -3
//    1111_1111_1111_1111_1111_1111_1111_0111 >> 2
// => 1111_1111_1111_1111_1111_1111_1111_1101

// ゼロ埋め右シフト演算子（>>>）：右にあふれたビットは破棄され、0のビットを左から詰める。
console.log((-9) >>> 2); // => 1073741821
//    1111_1111_1111_1111_1111_1111_1111_0111 >>> 2
// => 0011_1111_1111_1111_1111_1111_1111_1101

// 代入演算子（=）

